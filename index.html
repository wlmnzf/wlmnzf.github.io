<!doctype html>



  


<html class="theme-next pisces use-motion" lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta property="wb:webmaster" content="83391d5c1d7bc020" />








<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="丁洁的男朋友,csuncle,William,王立敏,会打代码的扫地王大爷,wlmnzf,中科院信工所,IIE,CAS" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="Secure Chip @ IIE CAS,I am interested in AI,WEB">
<meta property="og:type" content="website">
<meta property="og:title" content="会打代码的扫地王大爷">
<meta property="og:url" content="http://csuncle.com/index.html">
<meta property="og:site_name" content="会打代码的扫地王大爷">
<meta property="og:description" content="Secure Chip @ IIE CAS,I am interested in AI,WEB">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="会打代码的扫地王大爷">
<meta name="twitter:description" content="Secure Chip @ IIE CAS,I am interested in AI,WEB">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://csuncle.com/"/>





  <title>会打代码的扫地王大爷</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  





  <!-- hexo-inject:begin --><!-- hexo-inject:end --><script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?6a885c4fa76edbbfd2bea3f856135042";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>











  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">会打代码的扫地王大爷</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">CS Uncle</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://csuncle.com/2018/09/28/风行者Cache(一)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="William Wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="会打代码的扫地王大爷">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/28/风行者Cache(一)/" itemprop="url">风行者Cache（一）</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-28T19:57:32+08:00">
                2018-09-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Computer-Architecture/" itemprop="url" rel="index">
                    <span itemprop="name">Computer Architecture</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p style="text-align: center;"><br>风行者Cache（一）<br>==================<br></p>


<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;风，</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;高速缓存在计算机体系结构中的地位宛若风一般，程序员无法感受到它的存在，但是它却为系统新歌能的提升做出了巨大的贡献。</p>
<h3 id="Cache简史"><a href="#Cache简史" class="headerlink" title="Cache简史"></a>Cache简史</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最早的计算机中并不存在Cache结构，因为当时CPU和内存的速度都不是十分快，</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://csuncle.com/2018/08/27/GEM5中添加一个简单的IO模块/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="William Wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="会打代码的扫地王大爷">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/27/GEM5中添加一个简单的IO模块/" itemprop="url">GEM5中添加一个简单的IO模块（ORAM）</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-27T17:22:13+08:00">
                2018-08-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/gem5/" itemprop="url" rel="index">
                    <span itemprop="name">gem5</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p style="text-align: center;"><br>GEM5中添加一个简单的IO模块<br>==================<br></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;近期想要在Gem5中模拟ORAM（Oblivious RAM）的算法，因此开始折腾起了Gem5。</p>
<h4 id="ORAM简介"><a href="#ORAM简介" class="headerlink" title="ORAM简介"></a>ORAM简介</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了保护数据安全，我们经常对数据进行加密再进行存储。但是令人遗憾的是，很多时候，黑客可以通过大量统计CPU访存来总结出规律,从而推测出敏感信息。ORAM就是为了解决这个问题而诞生的。因此ORAM通常会需要在内存控制器之前对我们的访存地址或内容进行一些操作，来隐藏我们的访问模式。因此在这里我们需要在gem5中新增一个模块，这一模块将在内存控制器之前，用于接收来自CPU的访存消息，并进行处理，再将其传送给内存控制器。</p>
<h4 id="新增一个简单的IO模块"><a href="#新增一个简单的IO模块" class="headerlink" title="新增一个简单的IO模块"></a>新增一个简单的IO模块</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了实现上述目的，我们需要在CPU和内存控制器之间新建一个IO模块，用于实现ORAM算法。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如图1所示，CPU发出的消息经过L1_DCache-&gt;L2XBar-&gt;L2Cache-&gt;SystemXBar-&gt;DRAMSim2。我们计划在SystemXBar(membus)和DRAMSim2(mem_ctrls)之间添加一个ORAM新模块。</p>
<p><img src="/uploads/GEM5中添加一个简单的IO模块/config.png" alt="图1"></p>
<p style="text-align: center;"><br>图1 gem5输出的默认系统配置图<br></p>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. 在src目录下新建ORAM目录</span><br><span class="line">2. 复制src/learning_gem5/part2/目录下的simple_memobj.cc,simple_memobj.hh,SimpleMemobject.py以及SConscript到ORAM目录下。并且改名字为ORAMobj.cc,ORAMobj.hh,ORAMobj.py。</span><br><span class="line">3. 修改ORAM目录下的SConscript</span><br><span class="line">   新增以下ORAM配置 </span><br><span class="line">   + SimObject(&apos;ORAMobj.py&apos;)</span><br><span class="line">   + Source(&apos;ORAMobj.cc&apos;)</span><br><span class="line">   + DebugFlag(&apos;ORAMobj&apos;, &quot;For Learning gem5 Part 2.&quot;)</span><br><span class="line">   剩下的无关配置都可删除</span><br><span class="line">4. 此时还不行，由于内存中的一些多余的操作会导致接收包和发送包出现一些问题是的运行结果不正确，因此此时我们最好的方法是去除一些多余的函数，只留下接收数据包和发送数据包的函数即可。</span><br><span class="line"></span><br><span class="line">具体代码可参考github</span><br><span class="line">https://github.com/wlmnzf/gem5_add_a_new_module.git</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来我们需要修改se.py来将我们新增的这个模块加入到我们的系统配置中去。首先我们在cofigs/commom/MemConfig.py中修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Connect the controllers to the membus</span><br><span class="line">   for i in xrange(len(subsystem.mem_ctrls)):</span><br><span class="line">       if opt_mem_type == &quot;HMC_2500_1x32&quot;:</span><br><span class="line">           subsystem.mem_ctrls[i].port = xbar[i/4].master</span><br><span class="line">           # Set memory device size. There is an independent controller for</span><br><span class="line">           # each vault. All vaults are same size.</span><br><span class="line">           subsystem.mem_ctrls[i].device_size = options.hmc_dev_vault_size</span><br><span class="line">        else:</span><br><span class="line">            subsystem.mem_ctrls[i].port = xbar.master</span><br></pre></td></tr></table></figure></p>
<p>为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Connect the controllers to the membus</span><br><span class="line">   for i in xrange(len(subsystem.mem_ctrls)):</span><br><span class="line">       if opt_mem_type == &quot;HMC_2500_1x32&quot;:</span><br><span class="line">           subsystem.mem_ctrls[i].port = xbar[i/4].master</span><br><span class="line">           # Set memory device size. There is an independent controller for</span><br><span class="line">           # each vault. All vaults are same size.</span><br><span class="line">           subsystem.mem_ctrls[i].device_size = options.hmc_dev_vault_size</span><br><span class="line">       # else:</span><br><span class="line">       #     subsystem.mem_ctrls[i].port = xbar.master</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是因为我们需要在后面手工设置内存控制器连接我们新增的模块，而它默认会连接到内存控制器上，因此需要将其默认的连接取消掉，否则重复连接会导致错误。</p>
<p>接下来修改configs/example/se.py，在文件中找到如下代码行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MemConfig.config_mem(options, system)</span><br></pre></td></tr></table></figure></p>
<p>将其修改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MemConfig.config_mem(options, system)</span><br><span class="line">system.hello=ORAMobj()</span><br><span class="line">system.mem_ctrls[0].port=system.hello.mem_side</span><br><span class="line">system.hello.cache_side=system.membus.master</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外所需要注意的上面的例子中的cache_side和mem_side分别为模块的master端和slave端。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完成之后再次进行编译即可看到最终的效果了。而我们的m5out则会变成如图2所示的结构。可以看到相比于之前的系统配置，我们在里面新增了一个ORAM模块</p>
<p><img src="/uploads/GEM5中添加一个简单的IO模块/config1.png" alt="图2"></p>
<p style="text-align: center;"><br>图2 新增一个IO模块后的配置图<br></p>


          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://csuncle.com/2018/08/26/GEM5中利用Pydot输出系统配置图/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="William Wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="会打代码的扫地王大爷">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/26/GEM5中利用Pydot输出系统配置图/" itemprop="url">GEM5中利用Pydot输出系统配置图</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-26T07:22:13+08:00">
                2018-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/gem5/" itemprop="url" rel="index">
                    <span itemprop="name">gem5</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p style="text-align: center;"><br>GEM5中利用Pydot输出系统配置图<br>==================<br></p>

<p>安装python的Pydot包之后，当运行gem5进行模拟仿真之后，即可在m5out目录下找到config.pdf之类的配置图,如图1所示。</p>
<p>还可以通过dot命令将config.dot文件转换成自己需要的格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install pydot</span><br><span class="line">cd m5out</span><br><span class="line">dot -Tpng -o config.png config.dot</span><br></pre></td></tr></table></figure>
<p><img src="/uploads/GEM5中利用Pydot输出系统配置图/config.png" alt="图1"></p>
<p style="text-align: center;"><br>图1 gem5输出的系统配置图<br></p>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://csuncle.com/2018/08/25/Gem5中使用DRAMSim2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="William Wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="会打代码的扫地王大爷">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/25/Gem5中使用DRAMSim2/" itemprop="url">GEM5中使用DRAMSim2</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-25T17:22:13+08:00">
                2018-08-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/gem5/" itemprop="url" rel="index">
                    <span itemprop="name">gem5</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p style="text-align: center;"><br>GEM5中使用DRAMSim2<br>==================<br></p>

<h4 id="DRAMSim2"><a href="#DRAMSim2" class="headerlink" title="DRAMSim2"></a>DRAMSim2</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DRAMSim2是一个较为精确的DDR2/3内存模拟器，因为其仿真效果相当不错，因此在学术界接受度较高[1]。</p>
<h4 id="GEM5中集成DRAMSim2"><a href="#GEM5中集成DRAMSim2" class="headerlink" title="GEM5中集成DRAMSim2"></a>GEM5中集成DRAMSim2</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目前GEM5中已经给出了官方的集成方式。进入ext/dramsim2目录，参照readme中的方法下载DRAMSim2。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. cd ext/dramsim2</span><br><span class="line">2. git clone git://github.com/dramninjasUMD/DRAMSim2.git</span><br><span class="line">3. cd ../../</span><br><span class="line">4. scons build/X86/gem5.opt -j9 #重新编译gem5，这里给出默认的编译方式</span><br><span class="line">5. sudo build/X86/gem5.opt configs/example/se.py -c tests/test-progs/hello/bin/x86/linux/hello --cpu-type=&apos;TimingSimpleCPU&apos; --caches --l2cache  --mem-type=&apos;DRAMSim2&apos; #像这样指定内存类型的参数为DRAMSim2即可，--mem-type=&apos;DRAMSim2&apos;。别的配置可按照自己的需求进行修改。</span><br></pre></td></tr></table></figure>
<p><strong>注:</strong> 为了正确运行gem5，还需要将DRAMSim2中的配置system.ini.example和ini/DDR3_micron_32M_8B_x8_sg15.ini 中的空行删除掉</p>
<h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><blockquote>
<ol>
<li>Rosenfeld, Paul, Elliott Cooper-Balis, and Bruce Jacob. “DRAMSim2: A cycle accurate memory system simulator.” IEEE Computer Architecture Letters 10.1 (2011): 16-19.</li>
</ol>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://csuncle.com/2018/08/23/模型检验-计算树逻辑（CTL）小例/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="William Wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="会打代码的扫地王大爷">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/23/模型检验-计算树逻辑（CTL）小例/" itemprop="url">模型检验-计算树逻辑（CTL）小例</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-23T20:36:00+08:00">
                2018-08-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Model-checking/" itemprop="url" rel="index">
                    <span itemprop="name">Model checking</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Model-checking/Formal-Method/" itemprop="url" rel="index">
                    <span itemprop="name">Formal Method</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p style="text-align: center;"><br>形式化验证调研报告<br>==================<br></p>

<p><img src="/uploads/CTL小例/1.png" alt=""></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AX是相对于初始节点（x=1）开始的树而言的，由于AX表示对于任何从初始节点(x=1)开始的路径中的下一个节点，因此EX则是相对于初始节点的子节点（x=2）开始的子树而言的。EX(x=4)表示存在从节点(x=2)开始的路径，使得子树的初始节点(x=2)的下一个节点是节点(x=4)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Kripke结构K中，对于(x=1) =&gt; (x=2) =&gt; (x=3) =&gt; (x=1)的路径而言(x=2)的下一个节点是(x=3)并不满足EX(x=4)，并不是对任何从初始节点(x=1)出发的路径都满足式子中的AX。因此K不满足式子AX EX(x=4)。相反K’中对于节点(x=2)而言，存在路径 (x=2) =&gt; (x=4) =&gt; (x=1) =&gt; (x=2)满足EX(x=4)，同时它也满足AX。因此K’满足。</p>
<p><img src="/uploads/CTL小例/2.png" alt=""></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AX(x=3) V AX(x=4)要求在K’中，从(x=2)出发的任何路径，下一个节点都是(x=3)或者都是(x=4)。但是K’中(x=2)节点的下一个节点或是(x=3)或是(x=4),并不满足条件。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://csuncle.com/2018/08/10/SPEC2006/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="William Wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="会打代码的扫地王大爷">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/10/SPEC2006/" itemprop="url">SPEC2006</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-10T11:09:01+08:00">
                2018-08-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Benchmarks/" itemprop="url" rel="index">
                    <span itemprop="name">Benchmarks</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p style="text-align: center;"><br>SPEC2006常见用法和问题<br>==================<br></p>

<h4 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Ubuntu16.04</span><br><span class="line"># 注意安装gFortran</span><br><span class="line">. ./install.sh</span><br><span class="line">. ./shrc</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般情况下经过以上步骤即可安装完毕，进行使用,注意需要执行shrc设置完环境变量以后才可正常执行后续的各种操作。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外SPEC官方并不建议使用root权限，因为所有的测试集并不需要修改系统文件。</p>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><blockquote>
<p>runspec int –noreportable –n=1 –size=test</p>
</blockquote>
<ul>
<li>正式运行SPEC2006之前需要跑一下test尺寸，test尺寸比较小，因此跑起来耗时教短，可用于确保所有测试集都可正常编译运行。</li>
<li>int：表明这是整数测试集，这个参数也可用fp，all代替，分表表示只使用浮点测试集和所有测试集。</li>
<li>–noreportable 不生成报告 –reportable生成报告，若开启将会生成诸如html，pdf等格式的报告。</li>
<li>–n=1:表示只跑一轮，每个测试集只会跑一遍。若要生成报告，则至少跑3轮</li>
<li>–size=test：表示这次只跑少量集合，用于测试所有集合是否都已经编译执行正确</li>
</ul>
<blockquote>
<p>runspec int –reportable  –size=ref -I</p>
</blockquote>
<ul>
<li>-I 表示跑benchmark的适合忽略错误，如果中途出错也不会停下来。</li>
<li>如果没有指定rate和copies则为测试speed，speed只能测试单核性能。</li>
<li>若想测试多核性能，则可通过 –rate=128进行指定，这里讲使用128个线程。</li>
<li>rate和speed指标的区别请看<br><a href="https://www.spec.org/cpu2006/Docs/readme1st.html#Q15" target="_blank" rel="noopener">Q15. What is the difference between a “rate” and a “speed” metric?</a></li>
</ul>
<blockquote>
<p>如何检测自己的电脑是多少核心的呢？</p>
</blockquote>
<ul>
<li><p>逻辑CPU核心数(包括超线程技术): </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo |grep &quot;processor&quot;|sort -u|wc -l</span><br></pre></td></tr></table></figure>
</li>
<li><p>物理CPU个数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;physical id&quot; /proc/cpuinfo|sort -u|wc -l</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="或者"><a href="#或者" class="headerlink" title="或者"></a>或者</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;physical id&quot; /proc/cpuinfo|sort -u</span><br></pre></td></tr></table></figure>
<ul>
<li><p>每个物理CPU上的真实内核个数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;cpu cores&quot; /proc/cpuinfo|uniq</span><br></pre></td></tr></table></figure>
</li>
<li><p>每个物理CPU上逻辑内核个数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;siblings&quot; /proc/cpuinfo|uniq</span><br></pre></td></tr></table></figure>
</li>
<li><p>若每个核心上的逻辑内核比真实内核多，则说明开启了超线程技术</p>
</li>
<li>来源<a href="https://zhidao.baidu.com/question/1367310944286874379.html?word=linux%E6%80%8E%E4%B9%88%E7%9C%8Bcpu%E6%A0%B8%E6%95%B0&amp;ms=1&amp;rid=7428484352289693960" target="_blank" rel="noopener">Linux读取CPU信息</a></li>
</ul>
<blockquote>
<p>runspec 481  –noreportable –n=1 </p>
</blockquote>
<ul>
<li>有时候为了修复编译错误，可以让他单独跑481这一项</li>
</ul>
<blockquote>
<p>runspec -c xxx.cfg</p>
</blockquote>
<ul>
<li>-c用于指定配置文件，如果没有指定，则默认使用根目录的config文件夹下的default.cfg作为配置文件</li>
</ul>
<h4 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h4><blockquote>
<p>gcc5.x如何跑SPEC2006</p>
</blockquote>
<ul>
<li>在无法通过的测试集的gcc编译选项上加 –std=gnu89</li>
</ul>
<blockquote>
<p>缺少库文件</p>
</blockquote>
<ul>
<li>在gcc的编译选项上加 -include /usr/include/memory.h   include 后面的路径需要换成自己的，这里只是举个例子</li>
</ul>
<blockquote>
<p>447.dealII 遇到 error: ‘ptrdiff_t’ does not name a type</p>
</blockquote>
<ul>
<li>linux下需要引入 <cstddef>头文件，使用上述方法在config文件中找到447.dealII的配置在CXXPORTABILITY后面加上 -include cstddef  -include cstdlib -include cstring</cstddef></li>
<li>进入的头文件若是系统库，则不需要具体路径</li>
</ul>
<blockquote>
<p><a href="https://github.com/GoogleCloudPlatform/PerfKitBenchmarker/issues/1120" target="_blank" rel="noopener">spec2006 fp test failed with 416.gamess and 481.wrf</a></p>
</blockquote>
<ul>
<li>416 miscompare 问题是gcc旧版本的bug，当开启O2优化的适合会出错</li>
<li>升级新版本gcc或者用-O0进行编译或者换一个编译器</li>
<li>483 end of file 问题，我是通过把配置文件中的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 如果不幸需要自己编译工具链，可能会遇到更多奇怪的问题</span><br><span class="line"></span><br><span class="line">&gt; Specmd5sum multiple definition of `getline&apos;</span><br><span class="line"></span><br><span class="line">- Specmd5sum文件夹中的库文件跟系统库文件的函数冲突了，打开md5sum.c，注释掉```#include &quot;getline.h&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>在perl中make时遇到 MAKE: *** NO RULE TO MAKE TARGET ‘&lt;COMMAND-LINE>‘</p>
</blockquote>
<ul>
<li>这是因为gcc在高版本中改变了输出，以至于这里没有及时过滤掉，其实只要将makefile（注意不是Makefile）中&lt;command-line><br>的那一行全删掉即可。</li>
<li>这里有个问题是，buildtools每次编译都会将之前生成的东西清空，然后重新生成makefile文件，因此手工删除makefile中的<command-line>会失败。</command-line></li>
<li><p>于是自己随便在网上找了一段代码用于删除makefile文件中的’&lt;command-line>‘</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">void Delete(char* filepath, char str[])</span><br><span class="line">&#123;</span><br><span class="line">	char buf[4096];    //每读取一行，都将内容放到该数组中</span><br><span class="line">	FILE* fp = fopen(filepath, &quot;r&quot;);     //filepath里是原内容 </span><br><span class="line"> </span><br><span class="line">	FILE* fpt = fopen(&quot;temp&quot;, &quot;w&quot;);    //将filepath文件第n行内容删除后存入temp.txt中 </span><br><span class="line">	</span><br><span class="line">	while(!feof(fp)) </span><br><span class="line">	&#123;  </span><br><span class="line">	   fgets(buf,sizeof(buf), fp);  </span><br><span class="line">		if (!strstr(buf,str)) </span><br><span class="line">		&#123;      </span><br><span class="line">		  fprintf(fpt, &quot;%s&quot;, buf); </span><br><span class="line">                  printf(&quot;%s\n&quot;,buf);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	fclose(fp);</span><br><span class="line">	fclose(fpt);</span><br><span class="line"> </span><br><span class="line">	fpt = fopen(&quot;temp&quot;, &quot;r&quot;);</span><br><span class="line">    fp = fopen(filepath, &quot;w&quot;);</span><br><span class="line">    fgets(buf, sizeof(buf), fpt);	</span><br><span class="line">    while(!feof(fpt))</span><br><span class="line">	&#123;</span><br><span class="line">	   fprintf(fp, &quot;%s&quot;, buf);</span><br><span class="line">       fgets(buf, sizeof(buf), fpt);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	fclose(fp);</span><br><span class="line">	fclose(fpt);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">void main()</span><br><span class="line">&#123; </span><br><span class="line">	Delete(&quot;x2p/makefile&quot;, &quot;command&quot;);  </span><br><span class="line">    Delete(&quot;makefile&quot;, &quot;command&quot;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将上述代码另存为delete.c,置于工具链中的perl-5.8.7根目录下</p>
</li>
<li>并修改buildtools中的shell脚本,如下打加号的部分<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  DYLD_LIBRARY_PATH=`pwd`</span><br><span class="line">  export LD_LIBRARY_PATH DYLD_LIBRARY_PATH</span><br><span class="line">  ./Configure   -dOes -Ud_flock $PERLFLAGS -Ddosuid=undef -Dprefix=$INSTALLDIR -Dd_bincompat3=undef -A ldflags=-L$&#123;INSTALLDIR&#125;/lib -A ccflags=-I$&#123;INSTALLDIR&#125;/include -Ui_db -Ui_gdbm -Ui_ndbm -Ui_dbm -Uuse5005threads ; testordie &quot;error configuring perl&quot;</span><br><span class="line"></span><br><span class="line">+  gcc -o del delete.c</span><br><span class="line">+  ./del</span><br><span class="line">+  cd x2p</span><br><span class="line">+    $MYMAKE</span><br><span class="line">+  cd ../</span><br><span class="line">+  ./del</span><br><span class="line"></span><br><span class="line">  $MYMAKE; testordie &quot;error building perl&quot;</span><br><span class="line">  ./perl installperl; testordie &quot;error installing perl&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://csuncle.com/2018/08/03/形式化方法调研报告/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="William Wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="会打代码的扫地王大爷">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/03/形式化方法调研报告/" itemprop="url">形式化验证调研报告</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-03T21:34:08+08:00">
                2018-08-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/形式化方法/" itemprop="url" rel="index">
                    <span itemprop="name">形式化方法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p style="text-align: center;"><br>形式化验证调研报告<br>==================<br></p>

<p style="text-align: center;">王立敏</p>


<p style="text-align: center;">中国科学院信息工程研究所 第五实验室 北京 中国100093</p>

<p><strong>摘要</strong>2018年初，Spectre和Meltdown漏洞的发现，使得芯片安全备受重视。然而传统的基于仿真的芯片验证方法由于测试样例覆盖不完全，验证过程耗时巨大，逐渐适应不了日益复杂的芯片了。形式化方法作为一种静态验证方法，正好可以解决这些问题。本文主要梳理了当前形式化方法检测的常见方法，并且列出他们的优缺点，以及前人对这些缺点的改良方法。</p>
<p>关键词<br><strong>芯片安全，形式化验证，二元决策图，时序逻辑，Petri网，定理证明，等效性检验，模型检验</strong></p>
<p style="text-align: center;">Formal Verification Investigation Report</p>

<p style="text-align: center;">Wang Liming<sup>1</sup></p><br><p style="text-align: center;">Institute of Information Engineering, Chinese Academy of Sciences, Beijing 100093, China</p>

<p><strong>Abstract</strong> At the beginning of 2018, the discovery of Spectre and Meltdown attacks made chip security receive much more concerns. However, due to the serious drawbacks in the simulation-based methods in tradition such as the test cases did not cover all of the inputs and the time consuming of the simulation, this method became inappropriate to validate the chips that became more and more complicated. Formal Methods is a static verification method, which would solve these problems that the simulation-based methods bright. This report would list their advantages and disadvantages, as well as the previous methods that attempt to solve these problems.</p>
<p><strong>Key words</strong> Chip security, Formal verification, Binary Decision Diagrams,Temporal logic, Petri net, Theorem Proving, Equivalence Checking, Model checking</p>
<h4 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a><strong>1</strong> 引言</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;近些年来，芯片的性能和规模不断提升，集成电路的设计也越来越复杂，使得引入错误和问题的可能性日益增加。但是传统的基于仿真的集成电路验证方法的覆盖率难以达到100%。而形式化方法作为一种静态测试的方法，通过数学的推理证明，理论上可以实现绝对安全，找出难以发现的错误，因此广受研究人员的关注。</p>
<h6 id="基于仿真的集成电路验证"><a href="#基于仿真的集成电路验证" class="headerlink" title="基于仿真的集成电路验证"></a>基于仿真的集成电路验证</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目前应用最广泛的依然是基于仿真的验证方法。这种验证方法通常需要一个测试基准，通常同时对待验证的电路和测试基准施加相同的激励，然后通过对比他们的输出来判断电路是否正确。这些输入向量可以事先生成，然后在测试期间从数据库读入，也可以边测试边生成。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于仿真的验证只能证明电路在指定的输入向量下输出正确，若要证明电路的正确性，输入向量必须覆盖电路的所有输入组合。但是现在集成电路十分复杂，要实现这一点是十分困难的。令人遗憾的是，许多不安全的因素或者错误都是出现在测试向量难以覆盖的地方[1]。而且这种验证方式主要用于发现逻辑漏洞，而并不能检查出芯片中的安全漏洞。</p>
<h6 id="基于形式化方法的验证"><a href="#基于形式化方法的验证" class="headerlink" title="基于形式化方法的验证"></a>基于形式化方法的验证</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于形式化方法的验证是通过数理逻辑推理的一种方法。一般分为形式等效性检验（Equivalence<br>Checking），定理证明（Theorem Proving）以及模型检查（Model<br>Checking），如图1所示。</p>
<p><img src="/uploads/形式化验证调研报告/Formal_Methods-types_ch.svg" alt="图1 形式化方法的分类"></p>
<p style="text-align: center;">图1 形式化方法的分类</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;形式等效性检验一般用于检测两个电路设计逻辑相等，电路设计一般使用硬件描述语言（Verilog或者VHDL）进行描述，然后综合成门级电路，接着再进行一系列的优化。这里的每一个步骤都会导致电路设计的改变，因此检查每一步操作前后的电路设计是否逻辑等效是有必要的。有些时候优化操作需要人为干预，因此也需要使用等效性检验来确保这些操作没有引入错误。除此之外，设计完成的芯片也需要与对应的黄金模型进行对比，以确保集成电路设计的正确性。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定理证明方法是一种将模型抽象为逻辑公式，然后使用自动的逻辑推理技术来验证电路是否正确的技术。但是定理证明方法在使用时需要专业人士事先制定大量的定理和推理策略。因此它在自动化推理方面能力较差，不适用大规模的系统。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;模型检验是一种基于状态迁移系统的自动验证技术。它最早是由Edmund M.<br>Clarke和他的研究生E.A. Emerson以及A.P.Sistla提出来的[2]。使用这种方法首先需要提出一系列规格属性，这些属性表示对电路的安全需求，系统只要满足这些属性，就能确保安全。然后建立一个电路系统的模型，即可通过模型检测方法自动地检测模型是否满足这些规格属性。模型检验一般用于电路和协议的验证。</p>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于仿真的集成电路验证需要输入向量，而形式化验证并不需要。前者是先生成输入向量，再验证输出向量，而后者的考虑方向则相反，要先指明什么样的输出是符合要求的，再利用形式化方法去证明它。由于基于仿真的集成电路验证存在覆盖率不能达到100%，以及仿真时间过长等问题，而形式化证明则正好能解决这些问题。因此形式化验证开始被研究人员广泛关注。</p>
<h4 id="模型的建立"><a href="#模型的建立" class="headerlink" title="模型的建立"></a><strong>模型的建立</strong></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要使用形式化方法，需要先为电路建立模型，这些模型通常用一些图的数据结构或者公式来表示。形式化模型建立完成后，即可使用形式化算法对其进行检验。</p>
<h6 id="二元决策图"><a href="#二元决策图" class="headerlink" title="二元决策图"></a>二元决策图</h6><h6 id="2-1-1-二元决策图概述"><a href="#2-1-1-二元决策图概述" class="headerlink" title="2.1.1 二元决策图概述"></a>2.1.1 二元决策图概述</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二元决策图（Binary Decision Diagrams，BDD）可以很好地表示一个布尔函数。所谓布尔函数，即定义域和值域都是布尔值的函数，布尔函数在电路设计和密码学方面有广泛的应用。由于电路的输入和输出都是二进制值，这意味着电路可以表示成一个布尔函数，因此使用BDD结构来表示电路是十分合适的。</p>
<h6 id="2-1-2一个例子"><a href="#2-1-2一个例子" class="headerlink" title="2.1.2一个例子"></a>2.1.2一个例子</h6><p style="text-align: center;">表1 f(x1,x2,x3)的真值表</p>

<table>
<thead>
<tr>
<th>x1</th>
<th>x2</th>
<th>x3</th>
<th>f(x1,x2,x3)</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设有一个电路，电路的功能如公式(1)所示。<br>$$<br>\begin{equation}<br>f(x1,x2,x3)=x1x2+x1\overline{x2}\overline{x3}   \tag{1}<br>\end{equation}<br>$$</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其真值表如表1所示。于是可得出该电路的BDD图，如图2，x1,x2,x3为变量，实线表示变量赋值为1，虚线表示变量赋值为0。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由表1真值表可得，当x1,x2,x3分别赋值为0时，f(x1,x2,x3)的值也为0。则如图2在BDD图中沿着x1,x2,x3,0之间的虚线最终也会到达0的地方。如图中所示这样变量有序的BDD图也可以称作有序二元决策图（Ordered Binary Decision Diagrams ，OBDD）图。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以发现，当x1赋值为0,x2也赋值为0时，无论x3赋何值，最终结果也是0，因此可以将BDD再做精简。如图3中简化后的BDD所示，可以将这条路径中的x3节点删除，直接将x2用虚线连接至0处，这个过程可称为BDD的简化，而最终的简化结果则称为简化的有序二元决策图（Reduced<br>Ordered Binary Decision Diagrams，ROBDD）。</p>
<p><img src="/uploads/形式化验证调研报告/BDD.svg" alt="图2 f(x1,x2,x3)的BDD图"></p>
<p style="text-align: center;">图2 f(x1,x2,x3)的BDD图</p>

<p><img src="/uploads/形式化验证调研报告/BDD-simply.svg" alt="图3 f(x1,x2,x3)的简化BDD图"></p>
<p style="text-align: center;">图3 f(x1,x2,x3)的简化BDD图</p>

<h6 id="2-1-3基于二元决策图的电路表示"><a href="#2-1-3基于二元决策图的电路表示" class="headerlink" title="2.1.3基于二元决策图的电路表示"></a>2.1.3基于二元决策图的电路表示</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于组合逻辑电路而言，可以直接使用上述方法生成BDD结构。但是对于时序逻辑电路而言，则需要根据其特点生成有限自动机（Finite State Machine，FSM），再使用BDD来表示FSM的状态变迁过程，在形式等效验证和符号模型检验中常采用这一方法来表示电路。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BDD本身不能减少状态空间，随着变量数的增加，状态空间数依然呈指数级上涨，但是它也有许多优点，比如表达形式简洁，并且配合图算法可实现快速的操作，用于表示电路十分合适。</p>
<h6 id="时序逻辑"><a href="#时序逻辑" class="headerlink" title="时序逻辑"></a>时序逻辑</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时序逻辑是逻辑领域中一个重要的组成部分，它在形式化验证中有十分重要的应用</p>
<p style="text-align: center;">表2 时序逻辑的操作</p>

<table>
<thead>
<tr>
<th>符号</th>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>θUψ</td>
<td>Until</td>
<td>若θUψ在路径上为真，则θ一直保持真直到ψ为真</td>
</tr>
<tr>
<td>θRψ</td>
<td>Release</td>
<td>若ψ为真，直到θ为真（或者θ永远不为真）则θRψ在路径上为真，</td>
</tr>
<tr>
<td>Xθ</td>
<td>Next</td>
<td>若Xθ在路径上为真，则下一个时刻θ为真</td>
</tr>
<tr>
<td>Fθ</td>
<td>Future</td>
<td>若Fθ在路径上为真，则θ最终一定为真</td>
</tr>
<tr>
<td>Gθ</td>
<td>Globally</td>
<td>若Gθ在路径上为真，则任何时刻，θ都为真</td>
</tr>
<tr>
<td>Aθ</td>
<td>All</td>
<td>表示对于任意路径</td>
</tr>
<tr>
<td>Eθ</td>
<td>Exists</td>
<td>表示存在这样的路径</td>
</tr>
</tbody>
</table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以使用如表2所示的符号来描述硬件系统的行为，例如我们要表示“信号A一直不变，直到上升沿才翻转”这一操作，则我们令p为“信号A不变”，q为“时钟到达上升沿”，则该操作可表示为当满足pUq使信号A翻转。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比较常用的时序逻辑是线性时序逻辑（Linear temporal logic，LTL）以及计算树逻辑（Computation tree logic，CTL）。线性时序逻辑是个线性结构，每一个时刻都只对应一个后继，计算树逻辑则是一个树状的分支结构。LTL可用于重点对象的分析，并且它可以使用公平的概念，但是对于一些可返回到初始状态的复杂系统，LTL则无法表示。CTL则相反，它无法使用公平的概念，但是却可以表达一些较为复杂的系统[3]。LTL和CTL各有自己的优势，E. A. Emerson 和 Joseph Y. Halpern 在 1986年提出了CTL*，统一了LTL和CTL。在传统的模型检验中，通常采用时序逻辑来描述电路。</p>
<h6 id="Petri网"><a href="#Petri网" class="headerlink" title="Petri网"></a>Petri网</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Petri网是一种重要的数学工具，Petri网对系统的并发性，异步性和不确定性具有很强的描述能力，一般主要是使用Petri网的可达图[4]。</p>
<p>Petri网通常为四元组N= \&lt;P,T,F,M0></p>
<p>P：库所（Place）的有限集</p>
<p>T：迁移（Transition）的有限集</p>
<p>F：F ⊆ (P x T) ∪ (T x P)，表示边的集合。∪前后分别表示输入函数集以及输出函数集。</p>
<p>M0：P->N，表示初始状态集</p>
<p>库所（Place）表示系统的状态。一般用 <div style="width: 20px;height: 20px;border: 2px solid black;border-radius: 50%;position: relative;"><div style="width: 15px;height: 15px;border: 1px solid #black;border-radius: 50%;position: absolute;margin: auto;left: 0;right: 0;top: 0;bottom: 0; black;"></div></div>表示。</p>
<p>迁移（Transition）则表示资源的消耗使用，一般用 <span style="display:block;width:50px;height:25px;background-color:black"></span>表示。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;连接库所与变迁的有向弧表示输入输出函数。用令牌Token表示库所中的资源数量，一般用●表示。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;资源会沿着有向弧流动，当资源足够时，便会触发某些操作的执行来使用和消耗资源。即令牌会不断沿着迁移流动，令牌在迁移之前积聚叫做迁移的使能（enabled），令牌积累到足够数量之后便能通过迁移，这一过程也叫迁移的激发(fire)。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图4表示一个互斥系统的Petri网，双方发出进入临界区的请求，当其中一方进入临界区时，另一方只能等待。图中的小黑点表示Token，最中间的库所t表示哪一方可优先访问临界区，当Idle中的Token传递到Wait时，t中个Token也会流到可优先进入临界区的那一方，于是便可以激发迁移Access，当经过Free之后，Token又将回到Idle和t中。</p>
<p><img src="/uploads/形式化验证调研报告/Petri网.svg" alt="图4 互斥模型的Petri网"></p>
<p style="text-align: center;">图4 互斥模型的Petri网</p>

<p>1.<strong>形式化方法</strong></p>
<h6 id="形式等效验证（Equivalence-Checking）"><a href="#形式等效验证（Equivalence-Checking）" class="headerlink" title="形式等效验证（Equivalence Checking）"></a>形式等效验证（Equivalence Checking）</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设我们有Spec1和Spec2两个模型。若需要验证综合优化前后两个模型是否逻辑相等，则Spec1和Spec2可分别表示综合优化前后的设计。若需要验证设计的正确性，Spec1通常为黄金模型，Spec2则为我们的设计。Spec1和Spec2通常使用相同的数据结构，例如BDD，再根据具体的需求使用诸如布尔SAT求解程序（求解可满足性问题）之类的算法来进行等效性检验。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然等效检验的检测效果不错，在工业上也得到了应用，但是在使用过程中依然需要高层次的专业人员去制定等效检验框架[5]。而且在复杂的电路中，等效性检验也存在状态空间数呈指数级增长的问题。虽然学术界提出了各种优化的方法，比如将复杂的等效检验切割成小的可比较集合进行处理[6]，或者利用算法优化减少空间消耗[7]，但是状态空间爆炸问题依然没有很好地解决。</p>
<h6 id="定理证明-Theorem-Proving"><a href="#定理证明-Theorem-Proving" class="headerlink" title="定理证明(Theorem Proving)"></a>定理证明(Theorem Proving)</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定理证明方法十分严格，跟数理逻辑结合十分紧密。一般使用高阶逻辑（Higher-Order<br>Logic，HOL） 系统来进行证明。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要验证一个大的系统，通常采用目标制导的方式。将系统用HOL表示出来之后，再分为若干个子命题分别证明。定理证明方法对硬件模块的验证一般会用到抽象技术和层次化验证技术</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在证明之前需要对系统进行建模，Mike Gordon在论文[8]中提出可以直接利用HOL来为硬件建模。一个器件模块只有输入输出，这些输入输出可以用HOL中的谓词和函数表示，而模块之间的连接可用合取表示。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;抽象技术主要用于将系统的详细信息掩盖掉，只考虑需要关注的性质，这样可以方便算法的处理。根据关注对象的不同，可以分为不同的抽象。例如结构抽象掩盖了内部结构信息而只描述了设备的规范，而行为抽象则只对模块的部分行为进行定义，数据抽象则是通过一个映射，将现实中的数据抽象为一个较小的抽象数据集，比如布尔真值。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;层次化验证技术是将大的模型划分为小的模型，构建成一个树状结构，每一个子节点都是父节点的细化。下一层的正确性可以证明上一层的正确性，因此自下而上地证明可以确保根节点的模型的正确性。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定理证明方法在工业上也有一定的使用，但是定理证明方法需要对系统用严格语义的数学符号进行描述和推理，因此对用户而言十分复杂。而且并没有办法确保事先人为制定的规则和定理的正确性，因此最终的正确性也值得怀疑，即前提若有错误，则最终的验证结果就不一定正确。</p>
<h6 id="模型检验-Model-Checking"><a href="#模型检验-Model-Checking" class="headerlink" title="模型检验(Model Checking)"></a>模型检验(Model Checking)</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;模型检验是目前最为流行的形式化检测方法。但是它依然存在状态空间爆炸的问题，模型检测方法的发展几乎都是为了解决状态空间爆炸问题以及不同系统的适用性问题展开的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;状态空间爆炸问题一直制约着模型检验方法的发展，为此科研人员一直寻找合适的方法来解决这一问题，例如符号模型检验，偏序规约技术，以及近些年来十分热门的SAT技术。</p>
<h6 id="3-2-1符号模型检验"><a href="#3-2-1符号模型检验" class="headerlink" title="3.2.1符号模型检验"></a>3.2.1符号模型检验</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;符号模型检验的提出是解决状态空间爆炸问题的一个里程碑，它采用OBDD来描述电路。这使得模型检验可检查的系统规模大大增加，可以超过1020个状态。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;McMillan最先将OBDD引入模型检验技术[9]，提出了符号模型检验，最初时符号模型检验只是基于CTL公式的。该方法将CTL公式转化成OBDD图，并在OBDD上搜索状态空间。之后Clarke等人又提出了基于LTL的符号模型[10]。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;符号模型检验中，存在许多优化方法，最常见的两种方法是偏序规约技术[11]和抽象模型[12]。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于系统中可能存在两个并行的模块，而这些并行模块的运行组合有许多种，其中的一部分运行组合实际上是重复的。因此若能将并行的模块的运行次序固定下来，在验证过程中就可以减少许多重复的路径。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;抽象技术多用于需要数据处理的系统，符号模型检验的数据处理能力较弱，若是需要表达复杂的数据结构，则验证的复杂性会十分的高。因此可以将精确的数据值和抽象的数据集合做个映射，产生一个较小的抽象数据集，以此来简化符号模型检验的状态空间。</p>
<h6 id="3-2-1-SAT技术"><a href="#3-2-1-SAT技术" class="headerlink" title="3.2.1 SAT技术"></a>3.2.1 SAT技术</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于BDD的符号模型检验虽然使得可检验的系统规模增加了许多，但是状态空间爆炸问题并没有彻底解决，在BDD中，状态空间依然是指数级增长的。BDD可通过简化生成ROBDD来减少状态空间，但是可优化的余地依然比较少。随着SAT技术的发展，它也被引入到模型检验领域[13]。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SAT是NP完全的方法，因此它也是指数爆炸型的，为此Clarke等人提出了限界模型检验[14]。模型检验是通过对整个系统建模，并证明我们的模型是否满足我们定义的属性规格。而限界模型检验，则通过广度搜索的方法，从长度为1的路径开始搜索，搜索的路径长度逐渐递增，若能在长度为K的路径中搜索到不符合属性规格的路径，则停止搜索并报告这一反例。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然限界模型检验搜索到反例后即可停止这一机制使得其遍历的状态大大减少，但是它只检查了整个状态空间的一个子集，只能证明在限界中的那部分状态符合属性规格，而无法证明整个状态空间符合属性规格。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了解决这一完整性问题，目前学术界较为流行的做法是逼近所求的解，即迭代地计算可达状态的不动点，来验证这整个模型是否最终满足规约。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yakir Vizel等人于2015年整理了各种适用于SAT的优秀的算法，这些算法包括冲突驱动从句学习（Conflict-Driven<br>Clause Learning），随机局部搜索（Stochastic Local Search）[15]。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SAT技术在经过EDA社区与科研人员的相互促进之下，在过去十年中取得了很大的进步。虽然SAT在工业界也得到了应用，但是它依然无法很好地解决模型检验的状态空间爆炸问题和限界模型检验的完整性问题，此外并行SAT技术也是一个十分有前景的方向。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而为了解决不同系统的适应性问题，如第2部分所述，研究人员提出了许多不同的建模方式。传统的模型检验方法一般采用时序逻辑来描述电路。</p>
<h4 id="4-讨论"><a href="#4-讨论" class="headerlink" title="4 讨论"></a><strong>4</strong> 讨论</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;传统的基于仿真的验证方式虽然存在有覆盖不完全，耗时间等问题。而形式化验证则正好可以解决这些问题，然而这并不意味着形式化方法可以完全替代传统的仿真验证。形式化方法依然存在许多的局限性，目前最好的办法是将传统的仿真验证与形式化验证结合起来。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然在工业界和学术界的共同促进之下，形式化验证技术有了长足的进步。但依然存在不少进步的空间。模型验证是目前自动化水平最优的，很少需要手动干预，但是状态空间爆炸的问题依然令人十分困扰。为了提高形式化验证的速度,研究人员依然在尝试攻克检测技术的并行化的问题，这也是目前较为火的一个方向。此外为了能够使用到工业界，形式化验证必然还是需要提高检测技术的自动化水平，例如门级信息流的方法[16]利用关键信息只能从低安全级流向高安全级这一特性，简化了形式化方法建模的流程，使其可以自动生成模型。此外，纵观整个形式化验证方法的发展历程，可以发现许多形式化验证的突破，都是因为将一些已经存在的理论成果移植应用到工程中去，因此我们也可以从这一方面去考虑如何改进形式化验证的方法。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;形式化方法是个十分有前景而又十分重要的研究方向，不仅可以用于检测出难以发现的逻辑错误，也可以检查电路中隐藏的硬件木马，甚至发现较为隐秘安全漏洞。因此上述的一些形式化方法的局限依然值得我们在日后重点研究。</p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p>[1] LAM W K. Hardware Design Verification: Simulation and Formal Method-Based<br>Approaches (Prentice Hall Modern Semiconductor Design Series)[M]. Upper Saddle<br>River, NJ, USA: Prentice Hall PTR, 2005.</p>
<p>[2] CLARKE E M, EMERSON E A. Design and synthesis of synchronization skeletons<br>using branching time temporal logic[J]. : 20.</p>
<p>[3] 张瑞雪, 郝春梅, 王旭. 计算机形式验证方法研究综述[J]. 中国电子商务, 2011(5):<br>69–69.</p>
<p>[4] 蒋屹新, 林闯, 邢栩嘉. 基于线性时态逻辑的Petri网模型检测[J]. 系统仿真学报,<br>2003, 15(z1): 6–10.</p>
<p>[5] KREIKER J, TARLECKI A, VARDI M Y等. Modeling, Analysis, and Verification -<br>The Formal Methods Manifesto 2010 (Dagstuhl Perspectives Workshop 10482)[J].<br>HERBSTRITT M. 2011.</p>
<p>[6] KUEHLMANN A, KROHM F. Equivalence Checking Using Cuts and Heaps[J]. : 6.</p>
<p>[7] PARUTHI V, KUEHLMANN A. Equivalence checking combining a structural<br>SAT-solver, BDDs, and simulation[C]//IEEE Comput. Soc, 2000: 459–464.</p>
<p>[8] HAN J, STONE G. The implementation and verification of a conditional sum<br>adder[J]. 1988.</p>
<p>[9] MCMILLAN K L. Symbolic checking，An approachto the state explosion<br>problem[J]. : 212.</p>
<p>[10] CLARKE E, GRUMBERG O, HAMAGUCHI K. Another look at LTL model<br>checking[C]//International Conference on Computer Aided Verification. Springer,<br>1994: 415–427.</p>
<p>[11] PELED D. All from one, one for all: on model checking using<br>representatives[G]//COURCOUBETIS C. Computer Aided Verification. Berlin,<br>Heidelberg: Springer Berlin Heidelberg, 1993, 697: 409–423.</p>
<p>[12] CLARKE E M, GRUMBERG O, LONG D E. Model checking and abstraction[J]. ACM<br>transactions on Programming Languages and Systems (TOPLAS), 1994, 16(5):<br>1512–1542.</p>
<p>[13] 王瑞. 基于SAT的符号化模型检验技术研究[D]. 国防科学技术大学, 2014.</p>
<p>[14] CLARKE E, BIERE A, RAIMI R等. Bounded Model Checking Using Satisﬁability<br>Solving[J]. : 20.</p>
<p>[15] VIZEL Y, WEISSENBACHER G, MALIK S. Boolean Satisfiability Solvers and Their<br>Applications in Model Checking[J]. Proceedings of the IEEE, 2015, 103(11):<br>2021–2035.</p>
<p>[16] HU W, MAO B, OBERG J等. Detecting Hardware Trojans with Gate-Level<br>Information-Flow Tracking[J]. Computer, 2016, 49(8): 44–52.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://csuncle.com/2018/08/03/梅森旋转安全性分析及改进/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="William Wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="会打代码的扫地王大爷">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/03/梅森旋转安全性分析及改进/" itemprop="url">梅森旋转算法安全性分析及改进</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-03T09:30:08+08:00">
                2018-08-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cryptology/" itemprop="url" rel="index">
                    <span itemprop="name">密码学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p style="text-align: center;"><br>梅森旋转算法安全性分析及改进<br>======================<br></p>

<p style="text-align: center;">王立敏<sup>1</sup>,丁洁<sup>2</sup></p>


<p style="text-align: center;"><sup>1</sup>中国科学院信息工程研究所 第五实验室 北京 中国100093</p>

<p style="text-align: center;"><sup>2</sup>中国科学院信息工程研究所 第五实验室 北京 中国100093</p>

<p><strong>摘要</strong><br>梅森旋转算法是目前最流行的伪随机数发生器算法之一。梅森旋转算法存在许多缺点，例如当生成的伪随机数数量庞大时可预测以及无法通过部分统计测试。为了更好地深入了解和分析梅森旋转算法的安全性，本文将使用NIST<br>800-22文档中提到的统计测试等方法来对其生成的伪随机数进行静态的质量评估，并通过伪代码对该算法进行理论安全分析。由于梅森旋转算法生成伪随机数的速度十分快，而且开发者和研究人员们已经开发了许多梅森旋转算法的改进版本，甚至密码学安全的版本，因此当需要伪随机数时，选用梅森旋转算法作为伪随机数生成器是合理的。</p>
<p>关键词 <strong>梅森旋转算法，MT19937标准，统计测试，安全性分析</strong></p>
<p style="text-align: center;">The Analysis And Improvement Of Mersenne Twister</p>

<p style="text-align: center;">Wang Limin<sup>1</sup>, Ding Jie<sup>2</sup></p>

<p style="text-align: center;"><sup>1</sup>Institute of Information Engineering, Chinese Academy of Sciences, Beijing 100093, China</p><br><p style="text-align: center;"><sup>2</sup>Institute of Information Engineering, Chinese Academy of Sciences, Beijing 100093, China</p>

<p><strong>Abstract</strong> Mersenne Twister is one of the most useful pseudo random number generator algorithms. There are many shortcomings in Mersenne Twister. For example, it would be predictable and could not pass some of statistical tests when the algorithm generates plenty of pseudo random number generator algorithms. To analyze the security of algorithm, the statistical tests mentioned in NIST 800-22 would be used to evaluate the quality of Mersenne Twister and the pseudocode would be used to analyze the security of the algorithm. Mersenne Twister is very fast, and the developers and researchers have developed the improved versions of this algorithm, even the cryptographically secure version. For these reasons, choosing Mersenne Twister as the alternative pseudo random number generator is reasonable.</p>
<p><strong>Key words</strong> Mersenne Twister, MT19937, statistical test, the analysis of security</p>
<h4 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a><strong>1</strong> 前言</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;随机数在许多领域中都有着大量应用，例如密码学，游戏，数学统计。随机数主要分两类，分别是确定性随机数和非确定性随机数。非确定性随机数也可称为真随机数（True Random Number Generator, TRNG），主要来源于不可预测的物理或者化学熵源，例如电路噪声。真随机数发生器产生的随机数质量十分高，是最理想的随机数来源，但是由于产生的速度太慢，无法满足目前的信息的传输速度，因此目前确定性随机数依然被广泛使用。确定性随机数发生器也称作伪随机数发生器（Pseudorandom Number Generator，PRNG）,它一般是一个随机数生成算法，由于算法是固定的，因此生成的随机数存在许多诸如可预测，质量不高的缺点。因此在使用一个伪随机数发生器之前对其进行评估是十分有必要的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;梅森旋转是目前应用十分广泛的伪随机数生成器算法之一，已经集成在C++等编程语言的标准库中。梅森旋转生成的随机数能通过常见的静态统计测试，并且生成速度十分快，但是它依然存在许多缺点，例如当随机数数量足够时可预测。本文主要对该方法进行质量评估和安全性分析，并且提出一些改进意见。</p>
<h4 id="2-梅森旋转"><a href="#2-梅森旋转" class="headerlink" title="2 梅森旋转"></a><strong>2</strong> 梅森旋转</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MT19937以及MT19937-64标准分别实现了梅森旋转的32位以及64位算法，由于这两者只是参数不同，因此为方便起见，只实现和讨论MT19937标准。MT19937标准采用的梅森素数为219937<br>-1，因此它可生成的随机数范围为[0, 219937 -1]。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;梅森旋转算法实际使用的是旋转的广义反馈移位寄存器（Twisted Generalized Feedback Shift Register,GFSR）[2]，它主要分初始化，旋转生成随机数以及Xorshift后期处理三个步骤。由于MT19937的梅森算法中生成的随机数为32位，因此算法需要624个32位长的状态。在初始化阶段，算法的工作是将我们获得的随机种子经处理填充到所有的624个状态中</p>
<table>
<thead>
<tr>
<th>算法1：初始化</th>
</tr>
</thead>
<tbody>
<tr>
<td>输入: 一个随机种子<em>seed</em></td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mt[0] = seed </span><br><span class="line">a=1812433253  </span><br><span class="line">FOR i FROM 1 TO 623 </span><br><span class="line">  &#123; </span><br><span class="line">     mt[i] = f * (mt[i-1] XOR (mt[i-1] &gt;&gt; 30)) + i    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MT19937规定了算法1中的f值为1812433253 ，算法将输入的随机种子赋值给第0个状态，剩余的623个状态则用前一状态值的一系列操作进行赋值更新。当执行完这一算法后，全部的624个状态已经填充完毕，之后梅森算法便可以不断地生成伪随机数。</p>
<table>
<thead>
<tr>
<th>算法2：旋转生成随机数</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">lower_mask = (1 &lt;&lt; 31) - 1, </span><br><span class="line">upper_mask = (1 &lt;&lt; 31)</span><br><span class="line">a = 0x9908B0DF</span><br><span class="line">FOR i FROM 0 TO 623</span><br><span class="line">  &#123;</span><br><span class="line">    x = (mt[i] AND upper_mask) +(mt[(i+1) MOD 32] AND lower_mask)</span><br><span class="line">    xA = x &gt;&gt; 1</span><br><span class="line">    IF (x MOD 2) != 0</span><br><span class="line">    &#123;</span><br><span class="line">      xA = xA XOR a</span><br><span class="line">    &#125;</span><br><span class="line">    mt[i] = mt[(i + 397) MOD 624] XOR xA</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MT19937标准中定义a的值为0x9908B0DF，如算2所示，这部分是进行旋转操作。每生成624个伪随机数后，将执行一次算法2，重新更新624个状态，为生成下一批624个伪随机数做准备。</p>
<table>
<thead>
<tr>
<th>算法3:Xorshift后期处理</th>
</tr>
</thead>
<tbody>
<tr>
<td>输出：生成的伪随机数y</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b = 0x9d2c5680 </span><br><span class="line">c = 0xefc60000 </span><br><span class="line">y = mt[i] </span><br><span class="line">y = y XOR (y &gt;&gt; 11) </span><br><span class="line">y = y XOR ((y &lt;&lt; 7) AND b) </span><br><span class="line">y = y XOR ((y &lt;&lt; 15) AND c) </span><br><span class="line">y = y XOR (y &gt;&gt; 18)</span><br></pre></td></tr></table></figure>
<p>每个状态都需要经过Xorshift操作[3]以后才能成为最终输出的伪随机数，由于其中几乎都是移位，因此对CPU来说是十分快的。</p>
<h4 id="3-伪随机数发生器的评估"><a href="#3-伪随机数发生器的评估" class="headerlink" title="3 伪随机数发生器的评估"></a><strong>3</strong> 伪随机数发生器的评估</h4><p>正如前言部分所述，伪随机数发生器的评估是十分有必要的。伪随机数的质量和安全性一般有如下4个评判标准:</p>
<ol>
<li><p>随机数应该有很好的统计属性。例如各态遍历性</p>
</li>
<li><p>不能根据随机数的子序列合理推出其之前或者之后的随机数序列。并且子序列不能提高推出其之前和之后的伪随机序列的可能性。</p>
</li>
<li><p>不能根据内部状态合理推出其之前的内部状态。同样的也不能通过内部状态提高推出其之前的内部状态的可能性。</p>
</li>
<li><p>不能根据内部状态合理推出其之后的内部状态。也不能通过内部状态提高推出其之后的内部状态。</p>
</li>
</ol>
<h4 id="梅森旋转伪随机数的质量评估"><a href="#梅森旋转伪随机数的质量评估" class="headerlink" title="梅森旋转伪随机数的质量评估"></a>梅森旋转伪随机数的质量评估</h4><h6 id="4-1-NIST-800-22测试"><a href="#4-1-NIST-800-22测试" class="headerlink" title="4.1 NIST 800-22测试"></a>4.1 NIST 800-22测试</h6><p><img src="/uploads/梅森旋转安全性分析及改进/f71b3e0010ed24b848ba2860ab7d23f2.png" alt="图1 NIST 800-22随机数测试"></p>
<p style="text-align: center;">图1 NIST 800-22随机数测试</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NIST 800-22文档中提到了许多静态测试[4]，并且提供了测试程序NIST STS-2.1.2。David Johnston认为STS程序存在许多问题，例如经常奔溃，并且给出错误的测试结果，因此他修正了这些错误，并且给出了修正后的程序[5]。本测试采用了该自动化测试程序，在Summary一栏中左侧为测试名称，右侧为测试的统计参数P值，如图可见该梅森旋转算法可以通过文档中提到的所有静态测试。</p>
<h6 id="4-2-PractRand测试"><a href="#4-2-PractRand测试" class="headerlink" title="4.2 PractRand测试"></a><strong>4.2</strong> PractRand测试</h6><p><img src="/uploads/梅森旋转安全性分析及改进/ca660b0cad783b2adf8904c1670f940d.png" alt="图2 PractRand随机数测试"></p>
<p style="text-align: center;">图2 PractRand随机数测试</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PractRand也是目前常采用的测试程序。由图2所示，我们可以看到当随机数输出大小为128G时可以满足常见的静态统计测试，但是当输出随机数的数量达到256G时，BRANK测试无法通过。</p>
<h6 id="4-3-安全性分析"><a href="#4-3-安全性分析" class="headerlink" title="4.3 安全性分析"></a>4.3 安全性分析</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三部分的算法3将状态进行移位和亦或，最终输出为伪随机数，但是这一过程是可逆的。逆过程的具体证明和分析方法可参看oupo和plusletool的博客[6,7]。</p>
<table>
<thead>
<tr>
<th>算法4: 算法3的逆过程</th>
</tr>
</thead>
<tbody>
<tr>
<td>输出：梅森旋转的中间状态value</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">value = y </span><br><span class="line">value = value XOR (value &gt;&gt; 18)</span><br><span class="line">value = value XOR (value &lt;&lt; 15) AND 0xefc60000</span><br><span class="line">value = value </span><br><span class="line">       XOR ((value &lt;&lt; 7) &amp; 0x9d2c5680) </span><br><span class="line">       XOR ((value &lt;&lt; 14) &amp; 0x94284000) </span><br><span class="line">       XOR ((value &lt;&lt; 21) &amp; 0x14200000) </span><br><span class="line">       XOR ((value &lt;&lt; 28) &amp; 0x10000000) </span><br><span class="line">value =value </span><br><span class="line">       XOR (value &gt;&gt; 11) </span><br><span class="line">       XOR (value &gt;&gt; 22)</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;算法4描述了如何由伪随机数逆向恢复到梅森旋转算法的状态，因此若我们有624个梅森旋转算法生成的伪随机数，则我们可以由算法4恢复得到624个中间状态。再通过算法2和算法3即可得到接下来的伪随机数了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是由算法2可知，在进行旋转的时候，需要用到第i个状态，第i+1个状态以及第i+397个状态。因此如果敌手所得到的伪随机数量或者状态不足，则不能恢复所有的624个状态，便也不能继续预测接下来的伪随机数。而且算法2中的旋转操作会直接覆盖之前的内部状态，而且算法中跟mask进行与操作以及右移操作使得它无法再逆向推导出之前的状态，因此所幸的是即使敌手获取到足够量的伪随机数，也无法推出之前的伪随机数。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;梅森旋转算法可以满足常见应用的随机数需求，但是对于加密过程中所需的伪随机数，还是需要使用密码学安全的伪随机数（Cryptographically<br>Secure Pseudo-Random Number<br>Generator，CSPRNG），例如改进版的梅森旋转算法CryptMT。</p>
<h4 id="5-梅森旋转的改进方案"><a href="#5-梅森旋转的改进方案" class="headerlink" title="5 梅森旋转的改进方案"></a><strong>5</strong> 梅森旋转的改进方案</h4><h6 id="5-1-Hash输出"><a href="#5-1-Hash输出" class="headerlink" title="5.1 Hash输出"></a><strong>5.1</strong> Hash输出</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于梅森旋转算法可逆，我们可以通过泄露的伪随机数逆向推算出其内部状态，因此若将最终输出再进行Hash处理，如图3所示，即可使其生成的伪随机数不可逆，这样便可一定程度上提高梅森旋转算法的安全性。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hash算法不可逆，并且可以被用来生成伪随机数[8]，生成的随机数也具有很好的安全性。此外，SHA-3之所以拥有安全，不可逆等良好的特性，是因为采用了海绵结构，而且目前已经存在基于海绵结构的伪随机数生成器了[9,10]。综上所述，Hash算法可以用于生成质量较高的伪随机数，而且不可逆，若想要更灵活方便地移植使用，则也可以直接使用海绵结构。因此改进方案中采用Hash对梅森算法的输出做最后的处理使其不可逆是合理的。</p>
<p><img src="/uploads/梅森旋转安全性分析及改进/Hash.svg" alt="图3 经过Hash的梅森算法"></p>
<p style="text-align: center;">图3 经过Hash的梅森算法</p>

<h6 id="5-2-间隔输出"><a href="#5-2-间隔输出" class="headerlink" title="5.2 间隔输出"></a><strong>5.2</strong> 间隔输出</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由算法2可知，当梅森算法更新当前第i个状态时必须要用到第i+1个状态以及第i+397个状态。因此如图4所示假设将这些状态每隔一个进行处理输出为伪随机数，则即使敌手获取到大量的间隔伪随机数，并且将他们逆向恢复为算法的内部状态，也无法得到完整的624个状态。若没有完整的624个状态，则也无法继续预测生成接下去的伪随机数。</p>
<p><img src="/uploads/梅森旋转安全性分析及改进/output.svg" alt="图4 间隔输出的梅森算法"></p>
<p style="text-align: center;">图4 间隔输出的梅森算法</p>

<h4 id="6-结论"><a href="#6-结论" class="headerlink" title="6 结论"></a><strong>6</strong> 结论</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据第3部分所描述的4个评估标准可知梅森旋转算法并不完美。它依然无法通过其中的小部分统计测试，例如当生成的伪随机数达到256G时，无法通过BRANK测试。当敌手可以获得超过624个伪随机数时，可以通过逆向推导出其内部状态来预测其接下来生成的伪随机数。不过所幸的是由于其更新内部状态时的操作不可逆，使得它无法推导出已经生成过的伪随机数。对于第四个评估标准，事实上包括梅森旋转在内的确定性的伪随机数发生器都无法满足，因为算法固定，因此只要获取到内部状态，就一定可以推算出之后的伪随机数。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;梅森旋转算法虽然存在许多的缺点，比如当获取到的伪随机数数量足够多时是可以预测的，并且无法通过一些静态统计测试。但是由于它的许多操作都是基于移位的，因此速度更快一些。并且近些年来，许多开发者和研究人员都为改进梅森旋转算法做出了许多努力，诞生了许多更优秀的基于梅森旋转算法的随机数生成器，例如CryptMT，MTGP。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此在通用的软件上使用改进版的梅森旋转算法，以及在加密时使用密码学安全的梅森旋转算法（CryptMT）是十分合理的。</p>
<p><a href="https://github.com/wlmnzf/MT" target="_blank" rel="noopener">代码请看这里</a></p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p>[1] 徐恒. 确定性随机数产生器安全性分析及改进[D]. 上海交通大学, 2009.</p>
<p>[2] MATSUMOTO M, KURITA Y. Twisted GFSR generators[J]. ACM Transactions on<br>Modeling and Computer Simulation, 1992, 2(3): 179–194.</p>
<p>[3] MARSAGLIA G, OTHERS. Xorshift rngs[J]. Journal of Statistical Software,<br>2003, 8(14): 1–6.</p>
<p>[4] NIST S. 800-22[J]. A Statistical Test Suite for Random and Pseudorandom<br>Number Generators for Cryptographic Applications, 2000, 120.</p>
<p>[5] JOHNSTON D. sp800_22_tests: A python implementation of the SP800-22 Rev 1a<br>PRNG test suite[M]. 2018.</p>
<p>[6] PLUSLETOOL. メルセンヌ・ツイスタのtemperingの逆関数に関する考察[EB/OL]. Plus<br>Le Blog, 1414154296. (1414154296)[2018-07-15].<br><a href="http://plusletool.hatenablog.jp/entry/2014/10/24/213816" target="_blank" rel="noopener">http://plusletool.hatenablog.jp/entry/2014/10/24/213816</a>.</p>
<p>[7] 2014-10-16[EB/OL]. oupoの日記, [2018-07-15].<br><a href="http://d.hatena.ne.jp/oupo/20141016" target="_blank" rel="noopener">http://d.hatena.ne.jp/oupo/20141016</a>.</p>
<p>[8] BOLDYREVA A, KUMAR V. A New Pseudorandom Generator from Collision-Resistant<br>Hash Functions[G]//DUNKELMAN O. Topics in Cryptology – CT-RSA 2012. Berlin,<br>Heidelberg: Springer Berlin Heidelberg, 2012, 7178: 187–202.</p>
<p>[9] BERTONI G, DAEMEN J, PEETERS M等. Sponge-Based Pseudo-Random Number<br>Generators[G]//MANGARD S, STANDAERT F-X. Cryptographic Hardware and Embedded<br>Systems, CHES 2010. Berlin, Heidelberg: Springer Berlin Heidelberg, 2010, 6225:<br>33–47.</p>
<p>[10] BERTONI G, DAEMEN J, PEETERS M等. Duplexing the Sponge: Single-Pass<br>Authenticated Encryption and Other Applications[G]//MIRI A, VAUDENAY S. Selected<br>Areas in Cryptography</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://csuncle.com/2018/08/02/基于无保护AES算法的CPA攻击/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="William Wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="会打代码的扫地王大爷">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/02/基于无保护AES算法的CPA攻击/" itemprop="url">基于无保护AES芯片的 CPA攻击</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-02T19:30:08+08:00">
                2018-08-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cryptology/" itemprop="url" rel="index">
                    <span itemprop="name">密码学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p style="text-align: center;"><br>基于无保护AES芯片的 CPA攻击<br>===========================<br></p>


<p style="text-align: center;">王立敏<sup>1</sup>,丁洁<sup>2</sup> </p>


<p style="text-align: center;"><sup>1</sup>中国科学院信息工程研究所 第五实验室 北京 中国 100093</p>

<p style="text-align: center;"><sup>2</sup> 中国科学院信息工程研究所 第五实验室 北京 中国 100093</p>

<p><strong>摘要</strong> 高级加密标准（Advanced Encryption Standard，AES）是最常用的加密算法之一。为了提升实际应用中加解密操作的速度，或者在小型芯片上完成加密工作，AES通常被集成在加密芯片中。这使得其容易遭受侧信道攻击，尤其是能量分析攻击。本文中将采用相关能量分析（Correlation Power Analysis，CPA）对AES的能量迹和字节替换环节之间的关系进行统计分析来猜测其对应的密钥。其结果表明对于普通的无保护AES芯片，CPA攻击十分有效。</p>
<p>关键词 <strong>侧信道攻击，AES，密码芯片，相关能量分析，能量迹</strong></p>
<p style="text-align: center;">The CPA Attack For Unprotected AES Chips</p>

<p style="text-align: center;">Wang Limin<sup>1</sup>, Ding jie<sup>2</sup></p>

<p style="text-align: center;"><sup>1</sup> Institute of Information Engineering, Chinese Academy of Sciences, Beijing<br>100093, China  </p><br><p style="text-align: center;"><sup>2</sup> Institute of Information Engineering, Chinese Academy of Sciences, Beijing<br>100093, China</p>

<p><strong>Abstract</strong> Advanced Encryption Standard is one of the most commonly used encryption algorithms. In order to improve the speed of encrypted and decrypted operations or encrypt data on chips , the independent AES chip is used for encryption, which makes the chip vulnerable to Side-Channel Attack, especially to Power Analysis. This paper will guess the key of the AES by analyzing the correlation between power trace and SubBytes operation. This experiment shows that CPA attack can help crack secret keys more efficiently.</p>
<p><strong>Key words</strong> Side-Channel Attack, AES, Cipher Chip, Correlation,Power Analysis,Power Trace</p>
<h4 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a><strong>1</strong> 引言</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;侧信道分析技术在硬件安全领域中应用十分广泛。其中较为常见的一种是能量分析，它主要包括三种分析方法，简单能量分析（Simple Power Analysis, SPA），差分能量分析(Differential Power Analysis,DPA)以及相关能量分析(Correlation Power Analysis, CPA)。SPA和DPA最初由Paul Kocher, Joshua Jae, 和 Benjamin Jun 在1999年提出[1]。SPA利用的是密码芯片在进行不同的指令操作时所消耗的能量也不同这一特性，例如AES芯片在执行10轮操作时，它的10个能量消耗峰值将会十分明显。而DPA则更加复杂，它将测出来的能量迹分为几类，并计算它们均值的差，若假设的密钥是正确的，则会出现一个能量波峰，否则差值会在0附近波动。DPA是十分有效的能量攻击方法，但是它依然存在诸如幽灵峰值的问题，而本试验中给出的能量迹又足够多，因此为了提高破译密钥的正确性，本文将采用CPA来对AES进行攻击。CPA由E.Brier提出，是从DPA改进而来，它采用的是汉明重量模型[2]。</p>
<h4 id="2-AES介绍"><a href="#2-AES介绍" class="headerlink" title="2 AES介绍"></a><strong>2</strong> AES介绍</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AES在安全性不低于三重数据加密算法（Triple Data Encryption Algorithm，TDEA，也叫3DES）的同时，运算速度还比它快，因此被采用来替代原先的数据加密标准（Data Encryption Standard，DES），它具有很好的抗差分密码分析和线性密码分析的能力。AES根据密钥的长度的不同有三种不同的版本分别为AES-128，AES-192以及AES-256。本文只讨论利用CPA攻击无保护的AES-128算法，如算法1所示。</p>
<table>
<thead>
<tr>
<th>算法1：无保护的AES-128算法</th>
</tr>
</thead>
<tbody>
<tr>
<td>输入：明文X[0-15],轮密钥RoundKey[0-10] 输出：密文X[0-15]</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">for r = 0;r ≤ 8;r++ do</span><br><span class="line">     X = X ⊕ RoundKey[r]; /*加轮密钥*/</span><br><span class="line">     </span><br><span class="line">     for i = 0; i≤15; i++ do</span><br><span class="line">       Xi = SubBytes(Xi); /*字节替换*/</span><br><span class="line">     end</span><br><span class="line"></span><br><span class="line">     X = ShiftRows(X); /*行变换*/</span><br><span class="line">     X = *MixColumns*(X); /*列混淆*/</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">X = X⊕*RoundKey*[9]; /*最后一轮*/</span><br><span class="line"></span><br><span class="line">for I = 0; i≤15; i++ do</span><br><span class="line">    Xi = SubBytes(Xi);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">X = ShiftRows（X）</span><br><span class="line">X = X⊕RoundKey[10] /\*获取密文\*/</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AES-128算法需要经过10轮的操作，除了最后一轮之外，前9轮都包括加轮密钥，字节替换，行变换，列混淆这四个步骤，而第十轮则少一个列混淆。这里的11个128位的轮密钥是原始的128位密钥经过密钥扩展得到的。</p>
<h6 id="2-1-密钥扩展"><a href="#2-1-密钥扩展" class="headerlink" title="2.1 密钥扩展"></a><strong>2.1</strong> 密钥扩展</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;密钥扩展是将最初始的128位密钥扩展成11个轮密钥，方便每一轮中的操作。假设有这样一个128位的密钥，如图1所示。然后按每4字节为一列排列成图2所示的阵列。</p>
<p><img src="/uploads/基于无保护AES算法的CPA攻击/key-line.svg" alt="图1 给定的 AES密钥"></p>
<p style="text-align: center;">图1 给定的 AES密钥</p>


<p><img src="/uploads/基于无保护AES算法的CPA攻击/key-table.svg" alt="图2 密钥的排布"></p>
<p style="text-align: center;">图2 密钥的排布</p>


<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图2中每一列分配一个标记wi，第一列为w0，第二列为w1，以此类推。每一个轮密钥的第一列生成方式都较为复杂，这里以生成第5列（w4）为例。</p>
<p><img src="/uploads/基于无保护AES算法的CPA攻击/leftShift.svg" alt="图3 w3左移一位"></p>
<p style="text-align: center;">图3 w3左移一位</p>


<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如图3所示，当将最初的密钥排列完毕以后，需要将最后一列进行循环左移。并且左移后的每个元素都要经过S-BOX的字节替换处理，图四表示了这一过程。关于S-BOX字节替换的详细描述可参看2.3部分。</p>
<p><img src="/uploads/基于无保护AES算法的CPA攻击/key_xbox.svg" alt="图4 左移后经过S-BOX进行字节替换"></p>
<p style="text-align: center;">图4 左移后经过S-BOX进行字节替换</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设正在生成第i列密钥，这里是第5列，即为w4。由于此处是第二个轮密钥的第一列，则经过字节替换后的结果，需要与wi-4即w0以及rcon[i/4-1]即rcon[0]进行异或才能最终得出w4。其中rcon是如图6所示的10列数字。</p>
<p><img src="/uploads/基于无保护AES算法的CPA攻击/firstcolumn.svg" alt="图5 轮密钥第一列生成"></p>
<p style="text-align: center;">图5 轮密钥第一列生成</p>


<p><img src="/uploads/基于无保护AES算法的CPA攻击/rcon.svg" alt="图6 RCON数组"></p>
<p style="text-align: center;">图6 RCON数组</p>


<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只有轮密钥的第一列需要按照上述方法生成，接下来的三列则通过图7所示的方法，通过将wi-1以及wi-4异或来求得，例如这里轮密钥第二列w5，则是通过w4和w1异或得来的。</p>
<p><img src="/uploads/基于无保护AES算法的CPA攻击/nextColumn.svg" alt="图7 轮密钥第二列生成"></p>
<p style="text-align: center;">图7 轮密钥第二列生成</p>


<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之后的每一个轮密钥都将按照上述方法进行计算得出，轮密钥第一列wi=SubByte（LeftShift（wi-1））⊕wi-4⊕rcon[i/4-1],而第二，三，四列的计算规则为wi=wi-1⊕wi-4。图8即为新生成的轮密钥，可以很明显看出轮密钥0就是最开始输入的密钥，通常对AES的能量分析，都只分析第一轮，这一轮的轮密钥加操作使用的是轮密钥0，即原始输入的密钥。因此在进行CPA攻击时不需要经过密钥扩展这一步。</p>
<p><img src="/uploads/基于无保护AES算法的CPA攻击/allround.svg" alt="图8 新生成的轮密钥"></p>
<p style="text-align: center;">图8 新生成的轮密钥</p>


<h6 id="2-2-加轮密钥"><a href="#2-2-加轮密钥" class="headerlink" title="2.2 加轮密钥"></a><strong>2.2</strong> 加轮密钥</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AES经过密钥扩展得到轮密钥之后，将进行10轮操作，在每一轮操作中都需要加轮密钥。首先需要将明文和轮密钥按4字节为一列排成4列，分别命名为P0-P15和C0-C15,然后将明文和密文，按字节进行异或，即P0⊕C0-P15⊕C15。得到的最终结果可用于后续的字节替换。</p>
<p><img src="/uploads/基于无保护AES算法的CPA攻击/add.svg" alt="图9 轮密钥加"></p>
<p style="text-align: center;">图9 轮密钥加</p>


<h6 id="2-3-字节替换"><a href="#2-3-字节替换" class="headerlink" title="2.3 字节替换"></a><strong>2.3</strong> 字节替换</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字节替换一般使用的是Rijndael S-box[3],它将需要替换的字节的高四位作为横坐标，低四位作为纵坐标从S-BOX中选中对应的字节作为替代值。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如图10，待替代字节为0x01,则横坐标为高四位0x0,纵坐标为低四位0x1，从S-BOX中找到对应坐标的值0x7c，然后将其替换，图10展示S-BOX的替换过程，其中的S-BOX只是完整表格的一部分。</p>
<p><img src="/uploads/基于无保护AES算法的CPA攻击/sbox.svg" alt="图10 S-BOX替换"></p>
<p style="text-align: center;">图10 S-BOX替换</p>


<h4 id="3-CPA攻击"><a href="#3-CPA攻击" class="headerlink" title="3 CPA攻击"></a><strong>3</strong> CPA攻击</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CPA攻击主要采用汉明重量模型。计算汉明重量与对应能量迹之间的相关系数，若相关系数越大，则说明他们之间的相关性越强，若数据中某一猜测密钥对应的相关系数相比于其他相关系数要大的多，就可以说明这一猜测密钥是正确的。</p>
<h6 id="3-1-汉明重量"><a href="#3-1-汉明重量" class="headerlink" title="3.1 汉明重量"></a><strong>3.1</strong> 汉明重量</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;汉明重量可以表示一个二进制字符串中1的个数。已经有论文通过实验证明了输出结果的汉明重量与能量消耗之间有明确的关系，能量消耗随着汉明重量的增大而增大，而且有较为明确的界限，经过计算，它们的相关系数甚至能够达到0.9919[4]。这也说明CPA使用汉明重量模型是合理的。</p>
<h6 id="3-2-CPA攻击方法"><a href="#3-2-CPA攻击方法" class="headerlink" title="3.2 CPA攻击方法"></a><strong>3.2</strong> CPA攻击方法</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于字节替换占用了总能量消耗的大部分[5]，因此在CPA攻击时可以只考虑S-BOX的输出与能量迹之间的关系。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文将密钥分成16个子密钥分别破解，每一子密钥为一个字节。首先考虑第一个子密钥GuessKey的破解，这里需要将其从0遍历到255，然后每遍历一个值，就参照AES的一轮加密过程，将其与明文pt进行异或，异或之后再经过S-BOX的字节替换即可得到用于求解汉明重量的输入字符串input，如算法2第6行所示。值得注意的是AES加密需要对原始密钥进行密钥扩展，将一个原始密钥扩展成11个轮密钥，但是如算法2第4行所示，这里轮秘钥并不是密钥扩展得到的，而是直接对原始密钥进行了异或。这是因为，从本文2.1部分密钥扩展的过程可以看出，第一个轮密钥就是原始密钥本身，而且此处我们也只需要考虑AES的第一轮能量消耗和汉明重量之间的关系即可，因此在这里进行AES第一轮操作时可以不用进行密钥扩展而直接使用原始密钥。而后将输入字符串input的汉明重量求出，存在数组中，并求出他们与能量迹的Pearson相关系数。于是便可以得到横坐标为256个GuessKey，纵坐标为相关系数的统计图（请参看附件文件夹中的图），若遍历到的密钥不正确，则相关系数的波动幅度并不大，而当猜测的密钥正确时，对应的相关系数将会是一个明显的波峰。</p>
<table>
<thead>
<tr>
<th>算法2：CPA攻击算法</th>
</tr>
</thead>
<tbody>
<tr>
<td>输入：能量迹traces，明文pt 输出：密钥keys</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">for i = 0; i&lt;16 ;i++ do</span><br><span class="line">    for GuessKey=0;GuessKey&lt;256;GuessKey++ do</span><br><span class="line">       for j = 0;j&lt;TraceCnt;j++ do</span><br><span class="line">             input=pt[j][i]⊕GuessKey;</span><br><span class="line">             input=SubBytes(input);</span><br><span class="line">             hws[j]=HammingWeight(input);</span><br><span class="line">       end</span><br><span class="line"></span><br><span class="line">       for j = 0;j&lt;PointsCnt;j++ do</span><br><span class="line">             pccs[j]=PCC(Trans(traces)[j],hws);</span><br><span class="line">              /*PCC为求Pearson相关系数*/</span><br><span class="line">              /*Trans为矩阵转置*/</span><br><span class="line">       end</span><br><span class="line"></span><br><span class="line">       CPA[GuessKey]=Max(pccs)</span><br><span class="line">     end</span><br><span class="line"></span><br><span class="line">     keys[i]=Argmax(CPA)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h4 id="4-结论"><a href="#4-结论" class="headerlink" title="4 结论"></a><strong>4</strong> 结论</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本次实验所得到的能量迹数据为第36组，攻击源代码可以参看source目录，先通过ReadFile.py读取实验数据,并将其转为攻击代码需要的格式。再执行CPA.py进行攻击，执行过程中通过matplolt画图，可以很清晰地看出相关系数峰值，这些图可以在附件文件夹中看到。最终测算出来的密钥为0x77 70 26 8a 51 bf a9 b2 2f 6f 40 69 c3 95 db 5b。使用source目录下的AES代码[6]加密明文，并将得到的密文与给定的密文进行对比，可确定其为正确的密钥。因此可以认为本攻击手段采用CPA攻击是合理的。</p>
<p><a href="https://github.com/wlmnzf/CPA" target="_blank" rel="noopener">代码在此处下载</a></p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p>[1] KOCHER P, JAFFE J, JUN B. Differential power analysis[C]//Annual<br>International Cryptology Conference. Springer, 1999: 388–397.</p>
<p>[2] BRIER E, CLAVIER C, OLIVIER F. Correlation Power Analysis with a Leakage<br>Model[G]//JOYE M, QUISQUATER J-J. Cryptographic Hardware and Embedded Systems -<br>CHES 2004. Berlin, Heidelberg: Springer Berlin Heidelberg, 2004, 3156: 16–29.</p>
<p>[3] DAEMEN J. The Rijndael Block Cipher[J]. : 45.</p>
<p>[4] LO O, BUCHANAN W J, CARSON D. Power analysis attacks on the AES-128 S-box<br>using differential power analysis (DPA) and correlation power analysis (CPA)[J].<br>Journal of Cyber Security Technology, 2017, 1(2): 88–107.</p>
<p>[5] MORIOKA S, SATOH A. An Optimized S-Box Circuit Architecture for Low Power<br>AES Design[G]//KALISKI B S, KOÇ çetin K, PAAR C. Cryptographic Hardware and<br>Embedded Systems - CHES 2002. Berlin, Heidelberg: Springer Berlin Heidelberg,<br>2003, 2523: 172–186.</p>
<p>[6] Skycker/AES: Rijndael cipher algorithm[EB/OL]. [2018-07-31].<br><a href="https://github.com/Skycker/AES" target="_blank" rel="noopener">https://github.com/Skycker/AES</a>.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://csuncle.com/2018/02/11/Meltdown &  Spectre原理简要梳理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="William Wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="会打代码的扫地王大爷">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/11/Meltdown &  Spectre原理简要梳理/" itemprop="url">Meltdown &  Spectre原理简要梳理</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-11T09:43:13+08:00">
                2018-02-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vulnerability-analysis/" itemprop="url" rel="index">
                    <span itemprop="name">vulnerability analysis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spectre以及meltdown漏洞是前段时间，十分热门的两个漏洞，它们之所以广受重视，是因为它们根据的是体系结构的设计漏洞，而非针对某个系统或者某个软件，因此它几乎可以遍及大多数近代的CPU。</p>
<p>这里主要有三个漏洞:</p>
<ul>
<li>Variant 1: bounds check bypass (CVE-2017-5753)【绕过边界检查】</li>
<li>Variant 2: branch target injection (CVE-2017-5715)【分支目标注入】</li>
<li>Variant 3: rogue data cache load (CVE-2017-5754)【恶意数据缓存载入】<br>Spectre 主要利用前两个漏洞进行攻击，而meltdown则主要利用第三个漏洞进行攻击。</li>
</ul>
<h4 id="一、内存映射"><a href="#一、内存映射" class="headerlink" title="一、内存映射"></a>一、内存映射</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linux和Windows的内存映射方法是不同的，在linux中，虚拟空间地址有4G，0~3G为用户空间，3~4G为内核空间<br><img src="/uploads/Meltdown_Spectre原理简要梳理/1.jpg" alt="虚拟空间"></p>
<p>其中内核空间都相同，准确的讲是每个进程共享同一个内核空间<br><img src="/uploads/Meltdown_Spectre原理简要梳理/2.jpg" alt="虚拟内存"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linux在启动时会初始化一个进程，然后通过fork()生成子进程，Linux的fork机制会把父进程的页表和堆栈等一模一样地复制一份，然后在运行时，子进程通过缺页异常等操作来改变用户空间，如果内核空间部分也改变了，则只修改初始化进程的内核空间，其它子进程访问该页时，再通过缺页中断将这部分内容从父进程更新过来。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般来讲，当进程进行系统调用进入内核态的时候，它应该能够访问整个地址空间的，但是在这里只能访问自己的1G的地址空间，于是我们需要通过地址的映射，来使他可以访问整个空间，内核空间分为：ZONE_DMA（内存开始的16MB） 、ZONE_NORMAL（16MB~896MB）、ZONE_HIGHMEM（896MB ~ 结束）三个区域，其中0~896M是直接映射的，其余部分会进行非线性映射。</p>
<p><img src="/uploads/Meltdown_Spectre原理简要梳理/3.jpg" alt="这里写图片描述"></p>
<h4 id="二、Tomasulo算法"><a href="#二、Tomasulo算法" class="headerlink" title="二、Tomasulo算法"></a>二、Tomasulo算法</h4><p><img src="/uploads/Meltdown_Spectre原理简要梳理/4.png" alt="tomasylo"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原始的Tomasulo算法是为了寄存器重命名以便消除指令的数据相关，数据一到就可以执行指令。</p>
<ol>
<li>指令首先存在于指令队列之中。</li>
<li>指令一条一条地从队列中取出来，进行译码，然后放到对应的操作保留站中，比如加法指令放到加法保留站中。乘法指令放到乘除法保留站中。Vj和Vk中是用来存储源操作数的（已经就绪的源操作数值取自于浮点寄存器），若源操作数还没有准备好，则通过Qj和Qk指向操作数的保留站号，等到被指向的保留站中的操作计算出了结果，则结果可以通过结果总线传回到保留站中需要的指令，然后将其Qj和Qk中的值改为0（表示已经准备好）。</li>
<li>当Qj和Qk都为0时，那一条指令就可以送到乘/除器中执行。</li>
</ol>
<h4 id="三、乱序执行"><a href="#三、乱序执行" class="headerlink" title="三、乱序执行"></a>三、乱序执行</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最早期 CPU都是顺序执行的，前一条指令未执行完毕，则后一条指令必须等待着，就像我们烧水，必须洗茶壶，烧水，洗茶杯，倒水必须按照顺序来做，但是事实上烧水和洗茶杯可以同时执行，其实有很多指令也是如此，调整它们的顺序可以加快程序执行的速度</p>
<p>可能会造成乱序执行的原因：</p>
<ol>
<li>编译器为了优化而实现指令重排（静态调度）</li>
<li>CPU实现指令的多发射，以及并行执行，并为了优化实现指令的重排（动态调度）</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;程序的乱序执行并不意味着在所有步骤中，指令的顺序都是混乱的，事实上，指令在发射时和提交时依然是顺序的，只是在执行的过程中会打乱顺序。</p>
<p>为了支持乱序执行<br><img src="/uploads/Meltdown_Spectre原理简要梳理/5.png" alt="带有ROB的Tomasulo算法"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在Tomasulo  算法中加入了ROB来使得提交结果的时候能够按照顺序提交，执行的结果暂时存放于ROB而不直接写入寄存器堆，然后再按顺序提交数据。从而可以不出问题。</p>
<p>本次的漏洞就是利用了乱序执行这一特性来实现的</p>
<h4 id="四、分支预测"><a href="#四、分支预测" class="headerlink" title="四、分支预测"></a>四、分支预测</h4><p>由于在指令中存在许多跳转和分支，为了提前访问分支中的代码以节约时间，我们加入了分支预测功能</p>
<h6 id="静态分支"><a href="#静态分支" class="headerlink" title="静态分支"></a>静态分支</h6><p>对于所有的跳转指令，我们都预测执行跳转或者执行不跳转，则称其为静态跳转</p>
<h6 id="动态分支"><a href="#动态分支" class="headerlink" title="动态分支"></a>动态分支</h6><p>动态分支将会通过历史跳转信息来预测下一次分支应该选择跳转还是选择不跳转。在intel设计中有一个称为BTB(Branch Target Buffer)的部件，当我们执行分支指令时，会将执行结果和分支指令地址记录在其中，当下次取址时，查询其中的记录，若存在，则根据历史执行记录进行预测是否跳转。</p>
<p>若不存在此记录，我们将会使用静态分支预测器，我们一般将向上跳转的分支指令看作循环，对于循环我们倾向于接受跳转，而对于向下跳转，我们倾向于不跳转。</p>
<h4 id="五、Meltdown攻击"><a href="#五、Meltdown攻击" class="headerlink" title="五、Meltdown攻击"></a>五、Meltdown攻击</h4><p><img src="/uploads/Meltdown_Spectre原理简要梳理/6.png" alt="这里写图片描述"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在第一行，我们引发了一个异常，若程序按照顺序执行，第三行的access将不会被执行，但是由于程序是乱序执行的，因此在异常引发之前，第三行的access将被执行，但是执行结果存在ROB中不会被提交，当异常触发以后，第三行的执行结果将被撤销掉，从计算机外部看来第三行的access就跟从未被执行过一样，但是事实上它只是在后期被撤销了，这会带来一个小问题，就是在执行过程中，刚才读取的数据已经被存储到高速缓存中。</p>
<p>我们可以通过侧信道攻击来确认刚才访问的数据是什么。</p>
<p><img src="/uploads/Meltdown_Spectre原理简要梳理/7.png" alt="这里写图片描述"><br>这段代码揭示了攻击的关键部分<br>首先我们将访问内核地址并取内容到寄存器内，<br>若这一举动可以触发异常，则对应的寄存器清零，若异常未处理，则应用程序将会被终止，并且取出的值将会存入应用程序核心转储的寄存器中。我们要做的就是通过第5行将相应的寄存器清零，从而可以判断这是一个错误的值。然后再次重试，直到遇到一个不为0的值，然后将秘密的值作为地址，去做读取操作，以便cache记录到这个地址，实现侧信道攻击。</p>
<h4 id="六、Spectre"><a href="#六、Spectre" class="headerlink" title="六、Spectre"></a>六、Spectre</h4><p><img src="/uploads/Meltdown_Spectre原理简要梳理/8.png" alt="这里写图片描述"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spectre主要利用了分支预测和乱序执行的漏洞实现的，如图所示的代码，看起来十分地正常，若x小于array1的长度的时候，循环顺利执行。但是我们假设这里有一个存储密码的变量地址为secret，并且令a=secret-array1，于是我们可以使用array1[a]来表示secret的值。当多次执行循环的时候，我们的x满足循环条件，则我们的分支预测模块会认为下一个循环也满足循环条件而去预执行这个循环，若此时我们将a的值赋值给x，则分支预测模块预测本次循环为执行（其实并不会执行），CPU会预执行这个循环体，然后将我们存储密码的secret值取出来，并将其作为地址去访问array2，但是最终发现循环不应该被执行，于是刚才取出来的值将会被作废。但是我们的这个secret值的地址已经被存入到缓存中去。我们最终可以将array2读取一遍，若读取某个地址的时候，访问的时间特别短，则说明这个地址就是那个被存入缓存的地址（即我们的密码值）。</p>
<h4 id="七、参考"><a href="#七、参考" class="headerlink" title="七、参考"></a>七、参考</h4><p><a href="https://googleprojectzero.blogspot.co.at/2018/01/reading-privileged-memory-with-side.html" target="_blank" rel="noopener">https://googleprojectzero.blogspot.co.at/2018/01/reading-privileged-memory-with-side.html</a></p>
<p><a href="https://lwn.net/Articles/738975/" target="_blank" rel="noopener">https://lwn.net/Articles/738975/</a></p>
<p><a href="http://lib.csdn.net/article/linux/29085" target="_blank" rel="noopener">http://lib.csdn.net/article/linux/29085</a></p>
<p><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1272" target="_blank" rel="noopener">https://bugs.chromium.org/p/project-zero/issues/detail?id=1272</a></p>
<p><a href="http://blog.csdn.net/yiyeguzhou100/article/details/72875122" target="_blank" rel="noopener">http://blog.csdn.net/yiyeguzhou100/article/details/72875122</a></p>
<p><a href="https://bbs.pediy.com/thread-61327.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-61327.htm</a></p>
<p><a href="http://blog.csdn.net/muxiqingyang/article/details/6686738" target="_blank" rel="noopener">http://blog.csdn.net/muxiqingyang/article/details/6686738</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.png"
               alt="William Wang" />
          <p class="site-author-name" itemprop="name">William Wang</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">20</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">40</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/wlmnzf" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/wlmnzf" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/1505236542" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.linkedin.com/in/wlmnzf" target="_blank" title="Linkedin">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Linkedin
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://note.junyangz.com" title="Junyangz" target="_blank">Junyangz</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">William Wang</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

 <span>Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a></span>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






   
   
   
   
   <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
   <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
   
       <script type="text/javascript">
           function ShowGitment(){
               document.getElementById("gitment-display-button").style.display = "none";
               document.getElementById("gitment-container").style.display = "block";
               var gitment = new Gitment({
                   id: '', 
                   owner: 'wlmnzf',
                   repo: 'wlmnzf.github.io',
                   oauth: {
                       client_id: 'a8bc66fc03c165358b9b',
                       client_secret: '21860ee458dee914048f630f9f1a23ff3fc2f96b',
                   }});
               gitment.render('gitment-container');
           }
       </script>
   


  





  

  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

  

</body>
</html>
